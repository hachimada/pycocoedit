{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"pycocoedit"},{"location":"#what-is-pycocoedit","title":"What is pycocoedit?","text":"<p>pycocoedit is a lightweight Python library for querying, filtering, and rewriting COCO-format annotation files.</p> <p>Need to pull only 10 % of each class for a quick experiment? Need to keep only chosen categories\u2014or trim out a few you don\u2019t need? Maybe you just need the images whose filenames begin with night_?</p> <p>With pycocoedit you write those rules in two-or-three short, readable lines\u2014no manual JSON surgery, no error-prone for-loops.</p> <p>     Get started:      <code>pip install pycocoedit</code> </p>"},{"location":"#why-pycocoedit","title":"Why pycocoedit?","text":"<ul> <li> <p>Complex filtering in short, readable code   Quickly create subsets such as \"limit to 200 images per category, then exclude bboxes smaller than 32\u00b2.\"</p> </li> <li> <p>Automatic data cleanup   Removes annotations with invalid category or image IDs, and optionally cleans out images or categories without   annotations.</p> </li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from pycocoedit.objectdetection.data import CocoData\nfrom pycocoedit.objectdetection.filter import BoxAreaFilter, CategoryNameFilter, FilterType\n\n# 1. Load COCO JSON\ncoco = CocoData(\"annotations/train.json\")\n\n# 2. Keep only annotation with area between 10 and 100\nfile_filter = BoxAreaFilter(filter_type=FilterType.INCLUSION, min_area=10, max_area=100)\n\n# 3. Drop annotations with category names \"car\" and \"truck\"\ncat_filter = CategoryNameFilter(\n    filter_type=FilterType.EXCLUSION,\n    category_names=[\"car\", \"truck\"]\n)\n\n# 4. Apply filters and save\ncoco.add_filter(file_filter).add_filter(cat_filter).apply_filter().save(\"annotations.json\")\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pycocoedit\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"Feature What it gives you LEGO-style chainable filters One-liner <code>include</code> / <code>exclude</code> rules for images, annotations, categories, etc. Custom rules simply inherit <code>BaseFilter</code>, implement a short apply() method, and your custom logic is ready to use. Built-in data cleanup <code>CocoData.correct()</code> - Built-in data cleanup that removes orphaned annotations &amp; empty categories. Typed &amp; unit-tested IDE auto-completion and high confidence when refactoring."},{"location":"#task-support","title":"Task Support","text":"Task Supported version Object Detection \u2705 (<code>pycocoedit.objectdetection</code>) 0.0.1 Image Segmentation \u2705 (use <code>pycocoedit.objectdetection</code>) 0.0.1 Keypoint Detection \u274c (future release) Panoptic Segmentation \u274c (future release) Image Captioning \u274c (future release)"},{"location":"#roadmap","title":"Roadmap","text":"<ol> <li>Image Captioning</li> <li>key-point support</li> <li>Panoptic Segmentation</li> </ol> <p>Contributions and ideas are welcome\u2014feel free to open an issue or pull request on GitHub! \u00a9 2025 hachimada \u00b7 Licensed under the Apache License 2.0</p>"},{"location":"api/","title":"Api","text":""},{"location":"api/#pycocoedit","title":"pycocoedit","text":"<ul> <li><code>Object Detection</code> (can be used for Segmentation)</li> <li><code>Keypoint Detection</code> (future release)</li> <li><code>Panoptic Segmentation</code> (future release)</li> <li><code>Image Captioning</code> (future release)</li> </ul>"},{"location":"api/imagecaptioning/","title":"Image Captioning","text":"<p>Not yet implemented, but planned for future releases.</p>"},{"location":"api/keypointdetection/","title":"Keypoint Detection","text":"<p>Not yet implemented, but planned for future releases.</p>"},{"location":"api/objectdetection/","title":"Object Detection (Segmentation)","text":""},{"location":"api/objectdetection/#pycocoedit.objectdetection","title":"<code>pycocoedit.objectdetection</code>","text":""},{"location":"api/objectdetection/#pycocoedit.objectdetection.data","title":"<code>data</code>","text":"<p>COCO dataset editing module.</p> <p>This module provides functions and classes for managing and editing COCO format datasets for object detection tasks.</p>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.data.CocoData","title":"<code>CocoData</code>","text":"<p>Class for managing and manipulating COCO format datasets.</p> <p>This class provides methods to load, filter, correct and save COCO format datasets for object detection tasks.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>str or dict[str, Any]</code> <p>Either a file path to a JSON COCO dataset file or a dictionary containing the dataset.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the dataset is missing required keys or entries with required fields.</p> Source code in <code>pycocoedit/objectdetection/data.py</code> <pre><code>class CocoData:\n    \"\"\"\n    Class for managing and manipulating COCO format datasets.\n\n    This class provides methods to load, filter, correct and save\n    COCO format datasets for object detection tasks.\n\n    Parameters\n    ----------\n    annotation : str or dict[str, Any]\n        Either a file path to a JSON COCO dataset file or\n        a dictionary containing the dataset.\n\n    Raises\n    ------\n    KeyError\n        If the dataset is missing required keys or entries with required fields.\n    \"\"\"\n\n    def __init__(self, annotation: str | dict[str, Any]):\n        \"\"\"Initialize a CocoData object from a file path or dictionary.\"\"\"\n        if isinstance(annotation, dict):\n            dataset = copy.deepcopy(annotation)\n        else:\n            with open(annotation) as f:\n                dataset = json.load(f)\n        self.images: list[dict] = dataset[\"images\"]\n        self.annotations: list[dict] = dataset[\"annotations\"]\n        self.categories: list[dict] = dataset[\"categories\"]\n        self.licenses: list[dict] = dataset.get(\"licenses\", [])\n        self.info: dict[str, Any] = dataset.get(\"info\", {})\n\n        validate_images(self.images)\n        validate_categories(self.categories)\n        validate_annotations(self.annotations)\n\n        self.image_filters: Filters = Filters()\n        self.category_filters: Filters = Filters()\n        self.annotation_filters: Filters = Filters()\n\n        self.filter_applied = False\n\n    def add_filter(self, filter_: BaseFilter) -&gt; \"CocoData\":\n        \"\"\"\n        Add a filter.\n\n        Parameters\n        ----------\n        filter_ : BaseFilter\n            The filter to add.\n\n        Returns\n        -------\n        CocoData\n            Self reference for method chaining.\n        \"\"\"\n        if filter_.target_type == TargetType.IMAGE:\n            self.image_filters.add(filter_)\n        if filter_.target_type == TargetType.CATEGORY:\n            self.category_filters.add(filter_)\n        if filter_.target_type == TargetType.ANNOTATION:\n            self.annotation_filters.add(filter_)\n\n        # a new filter means filters need to be reapplied\n        self.filter_applied = False\n        return self\n\n    def apply_filter(self) -&gt; \"CocoData\":\n        \"\"\"\n        Apply all added filters to the dataset.\n\n        This method processes all filters, both inclusion and exclusion,\n        across all data types (images, categories, annotations).\n\n        Returns\n        -------\n        CocoData\n            Self reference for method chaining.\n        \"\"\"\n        targets: list[list[dict]] = [\n            self.images,\n            self.categories,\n            self.annotations,\n        ]\n        all_filters: list[Filters] = [\n            self.image_filters,\n            self.category_filters,\n            self.annotation_filters,\n        ]\n\n        def update(index: int, new_data: list[dict]):\n            \"\"\"\n            Update the appropriate data list based on index.\n\n            Parameters\n            ----------\n            index : int\n                Index indicating which data list to update.\n            new_data : list[dict]\n                New data to replace the current list.\n            \"\"\"\n            if index == 0:\n                self.images = new_data\n            if index == 1:\n                self.categories = new_data\n            if index == 2:\n                self.annotations = new_data\n\n        for i in range(len(targets)):\n            filters: Filters = all_filters[i]\n            include_filters: list[BaseFilter] = filters.include_filters\n            exclude_filters: list[BaseFilter] = filters.exclude_filters\n            if len(include_filters) != 0:\n                new_dicts = []\n                for d in targets[i]:\n                    for include_filter in include_filters:\n                        if include_filter.apply(d):\n                            new_dicts.append(d)\n                            break\n                update(i, new_dicts)\n            if len(exclude_filters) != 0:\n                new_dicts = []\n                for d in targets[i]:\n                    should_exclude = any(ex_f.apply(d) for ex_f in exclude_filters)\n                    if not should_exclude:\n                        new_dicts.append(d)\n                update(i, new_dicts)\n\n        self.filter_applied = True\n        return self\n\n    def correct(self, correct_image: bool = True, correct_category: bool = False) -&gt; \"CocoData\":\n        \"\"\"\n        Ensure dataset consistency after filtering.\n\n        This method removes annotations with category IDs not in categories,\n        annotations with image IDs not in images, and optionally removes\n        images with no annotations and categories with no annotations.\n\n        Parameters\n        ----------\n        correct_image : bool, optional\n            Whether to remove images that have no annotations, default is True.\n        correct_category : bool, optional\n            Whether to remove categories that have no annotations, default is False.\n\n        Returns\n        -------\n        CocoData\n            Self reference for method chaining.\n        \"\"\"\n        if not self.filter_applied:\n            self.apply_filter()\n\n        # Remove annotations with category_id not in categories\n        cat_ids = [cat[\"id\"] for cat in self.categories]\n        _annotations = []\n        for i in range(len(self.annotations)):\n            ann = self.annotations[i]\n            _cat_id = ann[\"category_id\"]\n            if ann[\"category_id\"] in cat_ids:\n                _annotations.append(ann)\n        self.annotations = _annotations\n\n        # Remove annotations with no images\n        img_ids = [img[\"id\"] for img in self.images]\n        _annotations = []\n        for i in range(len(self.annotations)):\n            ann = self.annotations[i]\n            _img_id = ann[\"image_id\"]\n            if ann[\"image_id\"] in img_ids:\n                _annotations.append(ann)\n        self.annotations = _annotations\n\n        if correct_image:\n            # Remove images with no annotations\n            img_ids = [ann[\"image_id\"] for ann in self.annotations]\n            _images = []\n            for img in self.images:\n                if img[\"id\"] in img_ids:\n                    _images.append(img)\n            self.images = _images\n\n        if correct_category:\n            # Remove categories with no annotations\n            cat_ids = [ann[\"category_id\"] for ann in self.annotations]\n            _categories = []\n            for cat in self.categories:\n                if cat[\"id\"] in cat_ids:\n                    _categories.append(cat)\n            self.categories = _categories\n\n        return self\n\n    def get_dataset(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get the dataset as a dictionary.\n\n        Returns\n        -------\n        dict\n            Dataset including info, licenses, images, categories and annotations.\n        \"\"\"\n        return {\n            \"info\": self.info,\n            \"licenses\": self.licenses,\n            \"images\": self.images,\n            \"categories\": self.categories,\n            \"annotations\": self.annotations,\n        }\n\n    def save(self, file_path: str, correct_image: bool = True, correct_category: bool = False) -&gt; None:\n        \"\"\"\n        Save the dataset to a JSON file.\n\n        Parameters\n        ----------\n        file_path : str\n            Path where the JSON file will be saved.\n        correct_image : bool, optional\n            Whether to remove images with no annotations before saving, default is True.\n        correct_category : bool, optional\n            Whether to remove categories with no annotations before saving, default is False.\n        \"\"\"\n        self.correct(correct_image=correct_image, correct_category=correct_category)\n        dataset = self.get_dataset()\n        with open(file_path, \"w\") as f:\n            json.dump(dataset, f)\n\n    def sample(self, n: int, correct_image: bool = True, correct_category: bool = False) -&gt; dict[str, Any]:\n        \"\"\"\n        Create a random sample of the dataset with n images.\n\n        Parameters\n        ----------\n        n : int\n            Number of images to sample.\n        correct_image : bool, optional\n            Whether to remove images with no annotations, default is True.\n        correct_category : bool, optional\n            Whether to remove categories with no annotations, default is False.\n\n        Returns\n        -------\n        dict\n            A new sampled dataset as a dictionary.\n\n        Raises\n        ------\n        ValueError\n            If n is greater than the number of images in the dataset.\n        \"\"\"\n        if not self.filter_applied:\n            self.apply_filter()\n\n        if n &gt; len(self.images):\n            raise ValueError(\n                f\"Number of images to sample is greater than the number of images in the dataset. n: {n}, number of images: {len(self.images)}\"\n            )\n\n        self.images = random.sample(self.images, n)\n        self.correct(correct_image, correct_category)\n        return self.get_dataset()\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.data.CocoData.__init__","title":"<code>__init__(annotation)</code>","text":"<p>Initialize a CocoData object from a file path or dictionary.</p> Source code in <code>pycocoedit/objectdetection/data.py</code> <pre><code>def __init__(self, annotation: str | dict[str, Any]):\n    \"\"\"Initialize a CocoData object from a file path or dictionary.\"\"\"\n    if isinstance(annotation, dict):\n        dataset = copy.deepcopy(annotation)\n    else:\n        with open(annotation) as f:\n            dataset = json.load(f)\n    self.images: list[dict] = dataset[\"images\"]\n    self.annotations: list[dict] = dataset[\"annotations\"]\n    self.categories: list[dict] = dataset[\"categories\"]\n    self.licenses: list[dict] = dataset.get(\"licenses\", [])\n    self.info: dict[str, Any] = dataset.get(\"info\", {})\n\n    validate_images(self.images)\n    validate_categories(self.categories)\n    validate_annotations(self.annotations)\n\n    self.image_filters: Filters = Filters()\n    self.category_filters: Filters = Filters()\n    self.annotation_filters: Filters = Filters()\n\n    self.filter_applied = False\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.data.CocoData.add_filter","title":"<code>add_filter(filter_)</code>","text":"<p>Add a filter.</p> <p>Parameters:</p> Name Type Description Default <code>filter_</code> <code>BaseFilter</code> <p>The filter to add.</p> required <p>Returns:</p> Type Description <code>CocoData</code> <p>Self reference for method chaining.</p> Source code in <code>pycocoedit/objectdetection/data.py</code> <pre><code>def add_filter(self, filter_: BaseFilter) -&gt; \"CocoData\":\n    \"\"\"\n    Add a filter.\n\n    Parameters\n    ----------\n    filter_ : BaseFilter\n        The filter to add.\n\n    Returns\n    -------\n    CocoData\n        Self reference for method chaining.\n    \"\"\"\n    if filter_.target_type == TargetType.IMAGE:\n        self.image_filters.add(filter_)\n    if filter_.target_type == TargetType.CATEGORY:\n        self.category_filters.add(filter_)\n    if filter_.target_type == TargetType.ANNOTATION:\n        self.annotation_filters.add(filter_)\n\n    # a new filter means filters need to be reapplied\n    self.filter_applied = False\n    return self\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.data.CocoData.apply_filter","title":"<code>apply_filter()</code>","text":"<p>Apply all added filters to the dataset.</p> <p>This method processes all filters, both inclusion and exclusion, across all data types (images, categories, annotations).</p> <p>Returns:</p> Type Description <code>CocoData</code> <p>Self reference for method chaining.</p> Source code in <code>pycocoedit/objectdetection/data.py</code> <pre><code>def apply_filter(self) -&gt; \"CocoData\":\n    \"\"\"\n    Apply all added filters to the dataset.\n\n    This method processes all filters, both inclusion and exclusion,\n    across all data types (images, categories, annotations).\n\n    Returns\n    -------\n    CocoData\n        Self reference for method chaining.\n    \"\"\"\n    targets: list[list[dict]] = [\n        self.images,\n        self.categories,\n        self.annotations,\n    ]\n    all_filters: list[Filters] = [\n        self.image_filters,\n        self.category_filters,\n        self.annotation_filters,\n    ]\n\n    def update(index: int, new_data: list[dict]):\n        \"\"\"\n        Update the appropriate data list based on index.\n\n        Parameters\n        ----------\n        index : int\n            Index indicating which data list to update.\n        new_data : list[dict]\n            New data to replace the current list.\n        \"\"\"\n        if index == 0:\n            self.images = new_data\n        if index == 1:\n            self.categories = new_data\n        if index == 2:\n            self.annotations = new_data\n\n    for i in range(len(targets)):\n        filters: Filters = all_filters[i]\n        include_filters: list[BaseFilter] = filters.include_filters\n        exclude_filters: list[BaseFilter] = filters.exclude_filters\n        if len(include_filters) != 0:\n            new_dicts = []\n            for d in targets[i]:\n                for include_filter in include_filters:\n                    if include_filter.apply(d):\n                        new_dicts.append(d)\n                        break\n            update(i, new_dicts)\n        if len(exclude_filters) != 0:\n            new_dicts = []\n            for d in targets[i]:\n                should_exclude = any(ex_f.apply(d) for ex_f in exclude_filters)\n                if not should_exclude:\n                    new_dicts.append(d)\n            update(i, new_dicts)\n\n    self.filter_applied = True\n    return self\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.data.CocoData.correct","title":"<code>correct(correct_image=True, correct_category=False)</code>","text":"<p>Ensure dataset consistency after filtering.</p> <p>This method removes annotations with category IDs not in categories, annotations with image IDs not in images, and optionally removes images with no annotations and categories with no annotations.</p> <p>Parameters:</p> Name Type Description Default <code>correct_image</code> <code>bool</code> <p>Whether to remove images that have no annotations, default is True.</p> <code>True</code> <code>correct_category</code> <code>bool</code> <p>Whether to remove categories that have no annotations, default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>CocoData</code> <p>Self reference for method chaining.</p> Source code in <code>pycocoedit/objectdetection/data.py</code> <pre><code>def correct(self, correct_image: bool = True, correct_category: bool = False) -&gt; \"CocoData\":\n    \"\"\"\n    Ensure dataset consistency after filtering.\n\n    This method removes annotations with category IDs not in categories,\n    annotations with image IDs not in images, and optionally removes\n    images with no annotations and categories with no annotations.\n\n    Parameters\n    ----------\n    correct_image : bool, optional\n        Whether to remove images that have no annotations, default is True.\n    correct_category : bool, optional\n        Whether to remove categories that have no annotations, default is False.\n\n    Returns\n    -------\n    CocoData\n        Self reference for method chaining.\n    \"\"\"\n    if not self.filter_applied:\n        self.apply_filter()\n\n    # Remove annotations with category_id not in categories\n    cat_ids = [cat[\"id\"] for cat in self.categories]\n    _annotations = []\n    for i in range(len(self.annotations)):\n        ann = self.annotations[i]\n        _cat_id = ann[\"category_id\"]\n        if ann[\"category_id\"] in cat_ids:\n            _annotations.append(ann)\n    self.annotations = _annotations\n\n    # Remove annotations with no images\n    img_ids = [img[\"id\"] for img in self.images]\n    _annotations = []\n    for i in range(len(self.annotations)):\n        ann = self.annotations[i]\n        _img_id = ann[\"image_id\"]\n        if ann[\"image_id\"] in img_ids:\n            _annotations.append(ann)\n    self.annotations = _annotations\n\n    if correct_image:\n        # Remove images with no annotations\n        img_ids = [ann[\"image_id\"] for ann in self.annotations]\n        _images = []\n        for img in self.images:\n            if img[\"id\"] in img_ids:\n                _images.append(img)\n        self.images = _images\n\n    if correct_category:\n        # Remove categories with no annotations\n        cat_ids = [ann[\"category_id\"] for ann in self.annotations]\n        _categories = []\n        for cat in self.categories:\n            if cat[\"id\"] in cat_ids:\n                _categories.append(cat)\n        self.categories = _categories\n\n    return self\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.data.CocoData.get_dataset","title":"<code>get_dataset()</code>","text":"<p>Get the dataset as a dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dataset including info, licenses, images, categories and annotations.</p> Source code in <code>pycocoedit/objectdetection/data.py</code> <pre><code>def get_dataset(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Get the dataset as a dictionary.\n\n    Returns\n    -------\n    dict\n        Dataset including info, licenses, images, categories and annotations.\n    \"\"\"\n    return {\n        \"info\": self.info,\n        \"licenses\": self.licenses,\n        \"images\": self.images,\n        \"categories\": self.categories,\n        \"annotations\": self.annotations,\n    }\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.data.CocoData.save","title":"<code>save(file_path, correct_image=True, correct_category=False)</code>","text":"<p>Save the dataset to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path where the JSON file will be saved.</p> required <code>correct_image</code> <code>bool</code> <p>Whether to remove images with no annotations before saving, default is True.</p> <code>True</code> <code>correct_category</code> <code>bool</code> <p>Whether to remove categories with no annotations before saving, default is False.</p> <code>False</code> Source code in <code>pycocoedit/objectdetection/data.py</code> <pre><code>def save(self, file_path: str, correct_image: bool = True, correct_category: bool = False) -&gt; None:\n    \"\"\"\n    Save the dataset to a JSON file.\n\n    Parameters\n    ----------\n    file_path : str\n        Path where the JSON file will be saved.\n    correct_image : bool, optional\n        Whether to remove images with no annotations before saving, default is True.\n    correct_category : bool, optional\n        Whether to remove categories with no annotations before saving, default is False.\n    \"\"\"\n    self.correct(correct_image=correct_image, correct_category=correct_category)\n    dataset = self.get_dataset()\n    with open(file_path, \"w\") as f:\n        json.dump(dataset, f)\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.data.CocoData.sample","title":"<code>sample(n, correct_image=True, correct_category=False)</code>","text":"<p>Create a random sample of the dataset with n images.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of images to sample.</p> required <code>correct_image</code> <code>bool</code> <p>Whether to remove images with no annotations, default is True.</p> <code>True</code> <code>correct_category</code> <code>bool</code> <p>Whether to remove categories with no annotations, default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A new sampled dataset as a dictionary.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If n is greater than the number of images in the dataset.</p> Source code in <code>pycocoedit/objectdetection/data.py</code> <pre><code>def sample(self, n: int, correct_image: bool = True, correct_category: bool = False) -&gt; dict[str, Any]:\n    \"\"\"\n    Create a random sample of the dataset with n images.\n\n    Parameters\n    ----------\n    n : int\n        Number of images to sample.\n    correct_image : bool, optional\n        Whether to remove images with no annotations, default is True.\n    correct_category : bool, optional\n        Whether to remove categories with no annotations, default is False.\n\n    Returns\n    -------\n    dict\n        A new sampled dataset as a dictionary.\n\n    Raises\n    ------\n    ValueError\n        If n is greater than the number of images in the dataset.\n    \"\"\"\n    if not self.filter_applied:\n        self.apply_filter()\n\n    if n &gt; len(self.images):\n        raise ValueError(\n            f\"Number of images to sample is greater than the number of images in the dataset. n: {n}, number of images: {len(self.images)}\"\n        )\n\n    self.images = random.sample(self.images, n)\n    self.correct(correct_image, correct_category)\n    return self.get_dataset()\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.data.validate_images","title":"<code>validate_images(images)</code>","text":"<p>Validate image entries in a COCO dataset.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>list[dict]</code> <p>List of image dictionaries to validate.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If any image dictionary is missing required keys \"id\", \"file_name\", \"width\", or \"height\".</p> Source code in <code>pycocoedit/objectdetection/data.py</code> <pre><code>def validate_images(images: list[dict]) -&gt; None:\n    \"\"\"\n    Validate image entries in a COCO dataset.\n\n    Parameters\n    ----------\n    images : list[dict]\n        List of image dictionaries to validate.\n\n    Raises\n    ------\n    KeyError\n        If any image dictionary is missing required keys \"id\", \"file_name\", \"width\", or \"height\".\n    \"\"\"\n    required_keys = [\"id\", \"file_name\", \"width\", \"height\"]\n    _validate_keys(images, required_keys, \"image\")\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.data.validate_categories","title":"<code>validate_categories(categories)</code>","text":"<p>Validate category entries in a COCO dataset.</p> <p>Parameters:</p> Name Type Description Default <code>categories</code> <code>list[dict]</code> <p>List of category dictionaries to validate.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If any category dictionary is missing required keys \"id\", \"name\" or \"supercategory\".</p> Source code in <code>pycocoedit/objectdetection/data.py</code> <pre><code>def validate_categories(categories: list[dict]) -&gt; None:\n    \"\"\"\n    Validate category entries in a COCO dataset.\n\n    Parameters\n    ----------\n    categories : list[dict]\n        List of category dictionaries to validate.\n\n    Raises\n    ------\n    KeyError\n        If any category dictionary is missing required keys \"id\", \"name\" or \"supercategory\".\n    \"\"\"\n    required_keys = [\"id\", \"name\", \"supercategory\"]\n    _validate_keys(categories, required_keys, \"category\")\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.data.validate_annotations","title":"<code>validate_annotations(annotations)</code>","text":"<p>Validate annotation entries in a COCO dataset.</p> <p>Parameters:</p> Name Type Description Default <code>annotations</code> <code>list[dict]</code> <p>List of annotation dictionaries to validate.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If any annotation dictionary is missing required keys \"id\", \"image_id\", \"category_id\", \"bbox\", \"area\" or \"segmentation\".</p> Source code in <code>pycocoedit/objectdetection/data.py</code> <pre><code>def validate_annotations(annotations: list[dict]) -&gt; None:\n    \"\"\"\n    Validate annotation entries in a COCO dataset.\n\n    Parameters\n    ----------\n    annotations : list[dict]\n        List of annotation dictionaries to validate.\n\n    Raises\n    ------\n    KeyError\n        If any annotation dictionary is missing required keys \"id\",\n        \"image_id\", \"category_id\", \"bbox\", \"area\" or \"segmentation\".\n    \"\"\"\n    required_keys = [\"id\", \"image_id\", \"category_id\", \"bbox\", \"area\", \"segmentation\"]\n    _validate_keys(annotations, required_keys, \"annotation\")\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.filter","title":"<code>filter</code>","text":"<p>Filter module for COCO dataset.</p> <p>This module provides filter implementations for COCO dataset manipulation. Filters can be used to include or exclude specific elements from the dataset based on various criteria.</p>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.filter.FilterType","title":"<code>FilterType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration for filter types.</p> <p>Attributes:</p> Name Type Description <code>INCLUSION</code> <code>int</code> <p>Filter to include matching elements (value=1).</p> <code>EXCLUSION</code> <code>int</code> <p>Filter to exclude matching elements (value=2).</p> Source code in <code>pycocoedit/objectdetection/filter.py</code> <pre><code>class FilterType(Enum):\n    \"\"\"\n    Enumeration for filter types.\n\n    Attributes\n    ----------\n    INCLUSION : int\n        Filter to include matching elements (value=1).\n    EXCLUSION : int\n        Filter to exclude matching elements (value=2).\n    \"\"\"\n\n    INCLUSION = 1\n    EXCLUSION = 2\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.filter.TargetType","title":"<code>TargetType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration for target types that can be filtered.</p> <p>Attributes:</p> Name Type Description <code>IMAGE</code> <code>str</code> <p>Target type for image filters.</p> <code>ANNOTATION</code> <code>str</code> <p>Target type for annotation filters.</p> <code>CATEGORY</code> <code>str</code> <p>Target type for category filters.</p> Source code in <code>pycocoedit/objectdetection/filter.py</code> <pre><code>class TargetType(Enum):\n    \"\"\"\n    Enumeration for target types that can be filtered.\n\n    Attributes\n    ----------\n    IMAGE : str\n        Target type for image filters.\n    ANNOTATION : str\n        Target type for annotation filters.\n    CATEGORY : str\n        Target type for category filters.\n    \"\"\"\n\n    IMAGE = \"image\"\n    ANNOTATION = \"annotation\"\n    CATEGORY = \"category\"\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.filter.BaseFilter","title":"<code>BaseFilter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all filter implementations.</p> <p>This class defines the common interface and basic functionality for all filter types used in COCO dataset manipulation.</p> <p>Parameters:</p> Name Type Description Default <code>filter_type</code> <code>FilterType</code> <p>The type of filter (inclusion or exclusion).</p> required <code>target_type</code> <code>TargetType</code> <p>The target data type this filter will be applied to.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If filter_type or target_type is None or not of the correct type.</p> Source code in <code>pycocoedit/objectdetection/filter.py</code> <pre><code>class BaseFilter(ABC):\n    \"\"\"\n    Abstract base class for all filter implementations.\n\n    This class defines the common interface and basic functionality\n    for all filter types used in COCO dataset manipulation.\n\n    Parameters\n    ----------\n    filter_type : FilterType\n        The type of filter (inclusion or exclusion).\n    target_type : TargetType\n        The target data type this filter will be applied to.\n\n    Raises\n    ------\n    ValueError\n        If filter_type or target_type is None or not of the correct type.\n    \"\"\"\n\n    def __init__(self, filter_type: FilterType, target_type: TargetType):\n        if not isinstance(filter_type, FilterType) or filter_type is None:\n            raise TypeError(\"filter_type must be a FilterType and not None.\")\n        if not isinstance(target_type, TargetType) or target_type is None:\n            raise TypeError(\"target_type must be a TargetType and not None.\")\n        self.filter_type: FilterType = filter_type\n        self.target_type: TargetType = target_type\n\n    @abstractmethod\n    def apply(self, data: dict) -&gt; bool:\n        \"\"\"Apply the filter to the data.\n\n        Implement logic within this function to determine what data to include or exclude to your dataset.\n\n        -  when ``self.filter_type`` is ``INCLUSION`` and this function return True, the data is included\n        -  when ``self.filter_type`` is ``INCLUSION`` and this function return False, the data is excluded\n        -  when ``self.filter_type`` is ``EXCLUSION`` and this function return True, the data is excluded\n        -  when ``self.filter_type`` is ``EXCLUSION`` and this function return False, the data is included\n\n        Parameters\n        ----------\n        data : dict\n            The data to filter.\n            data is expected to be as follows\n            - element of the images in the COCO format\n            - element of the annotations in the COCO format\n            - element of the categories in the COCO format\n        \"\"\"\n        raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.filter.BaseFilter.apply","title":"<code>apply(data)</code>  <code>abstractmethod</code>","text":"<p>Apply the filter to the data.</p> <p>Implement logic within this function to determine what data to include or exclude to your dataset.</p> <ul> <li>when <code>self.filter_type</code> is <code>INCLUSION</code> and this function return True, the data is included</li> <li>when <code>self.filter_type</code> is <code>INCLUSION</code> and this function return False, the data is excluded</li> <li>when <code>self.filter_type</code> is <code>EXCLUSION</code> and this function return True, the data is excluded</li> <li>when <code>self.filter_type</code> is <code>EXCLUSION</code> and this function return False, the data is included</li> </ul> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data to filter. data is expected to be as follows - element of the images in the COCO format - element of the annotations in the COCO format - element of the categories in the COCO format</p> required Source code in <code>pycocoedit/objectdetection/filter.py</code> <pre><code>@abstractmethod\ndef apply(self, data: dict) -&gt; bool:\n    \"\"\"Apply the filter to the data.\n\n    Implement logic within this function to determine what data to include or exclude to your dataset.\n\n    -  when ``self.filter_type`` is ``INCLUSION`` and this function return True, the data is included\n    -  when ``self.filter_type`` is ``INCLUSION`` and this function return False, the data is excluded\n    -  when ``self.filter_type`` is ``EXCLUSION`` and this function return True, the data is excluded\n    -  when ``self.filter_type`` is ``EXCLUSION`` and this function return False, the data is included\n\n    Parameters\n    ----------\n    data : dict\n        The data to filter.\n        data is expected to be as follows\n        - element of the images in the COCO format\n        - element of the annotations in the COCO format\n        - element of the categories in the COCO format\n    \"\"\"\n    raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.filter.Filters","title":"<code>Filters</code>","text":"<p>Container for managing multiple filters.</p> <p>This class collects and manages both inclusion and exclusion filters to be applied to a dataset.</p> Source code in <code>pycocoedit/objectdetection/filter.py</code> <pre><code>class Filters:\n    \"\"\"\n    Container for managing multiple filters.\n\n    This class collects and manages both inclusion and exclusion filters\n    to be applied to a dataset.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize an empty filters container.\"\"\"\n        self.include_filters: list[BaseFilter] = []\n        self.exclude_filters: list[BaseFilter] = []\n\n    def add(self, filter: BaseFilter) -&gt; None:\n        \"\"\"\n        Add a filter to the appropriate collection based on its type.\n\n        Parameters\n        ----------\n        filter : BaseFilter\n            The filter to add, either inclusion or exclusion type.\n        \"\"\"\n        if filter.filter_type == FilterType.INCLUSION and isinstance(filter, BaseFilter):\n            self.include_filters.append(filter)\n        if filter.filter_type == FilterType.EXCLUSION and isinstance(filter, BaseFilter):\n            self.exclude_filters.append(filter)\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.filter.Filters.__init__","title":"<code>__init__()</code>","text":"<p>Initialize an empty filters container.</p> Source code in <code>pycocoedit/objectdetection/filter.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize an empty filters container.\"\"\"\n    self.include_filters: list[BaseFilter] = []\n    self.exclude_filters: list[BaseFilter] = []\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.filter.Filters.add","title":"<code>add(filter)</code>","text":"<p>Add a filter to the appropriate collection based on its type.</p> <p>Parameters:</p> Name Type Description Default <code>filter</code> <code>BaseFilter</code> <p>The filter to add, either inclusion or exclusion type.</p> required Source code in <code>pycocoedit/objectdetection/filter.py</code> <pre><code>def add(self, filter: BaseFilter) -&gt; None:\n    \"\"\"\n    Add a filter to the appropriate collection based on its type.\n\n    Parameters\n    ----------\n    filter : BaseFilter\n        The filter to add, either inclusion or exclusion type.\n    \"\"\"\n    if filter.filter_type == FilterType.INCLUSION and isinstance(filter, BaseFilter):\n        self.include_filters.append(filter)\n    if filter.filter_type == FilterType.EXCLUSION and isinstance(filter, BaseFilter):\n        self.exclude_filters.append(filter)\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.filter.ImageFileNameFilter","title":"<code>ImageFileNameFilter</code>","text":"<p>               Bases: <code>BaseFilter</code></p> <p>Filter images based on their file names.</p> <p>Parameters:</p> Name Type Description Default <code>filter_type</code> <code>FilterType</code> <p>The type of the <code>filter.FilterType.INCLUSION</code> or <code>FilterType.EXCLUSION</code>. If <code>FilterType.INCLUSION</code>, the images with the file names in the <code>file_names</code> are included. If <code>FilterType.EXCLUSION</code>, the images with the file names in the <code>file_names</code> are excluded.</p> required <code>file_names</code> <code>list[str]</code> <p>List of file names to filter by.</p> required Source code in <code>pycocoedit/objectdetection/filter.py</code> <pre><code>class ImageFileNameFilter(BaseFilter):\n    \"\"\"\n    Filter images based on their file names.\n\n    Parameters\n    ----------\n    filter_type : FilterType\n        The type of the ``filter.FilterType.INCLUSION`` or ``FilterType.EXCLUSION``.\n        If ``FilterType.INCLUSION``, the images with the file names in the ``file_names`` are included.\n        If ``FilterType.EXCLUSION``, the images with the file names in the ``file_names`` are excluded.\n    file_names : list[str]\n        List of file names to filter by.\n    \"\"\"\n\n    def __init__(self, filter_type: FilterType, file_names: list[str]):\n        super().__init__(filter_type, TargetType.IMAGE)\n        self.file_names = file_names\n\n    @override\n    def apply(self, data: dict) -&gt; bool:\n        \"\"\"\n        Apply the filename filter to image data.\n\n        Parameters\n        ----------\n        data : dict\n            Image data containing a 'file_name' key.\n\n        Returns\n        -------\n        bool\n            True if the image filename is in the filter's file_names list,\n            False otherwise.\n        \"\"\"\n        return data[\"file_name\"] in self.file_names\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.filter.ImageFileNameFilter.apply","title":"<code>apply(data)</code>","text":"<p>Apply the filename filter to image data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Image data containing a 'file_name' key.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the image filename is in the filter's file_names list, False otherwise.</p> Source code in <code>pycocoedit/objectdetection/filter.py</code> <pre><code>@override\ndef apply(self, data: dict) -&gt; bool:\n    \"\"\"\n    Apply the filename filter to image data.\n\n    Parameters\n    ----------\n    data : dict\n        Image data containing a 'file_name' key.\n\n    Returns\n    -------\n    bool\n        True if the image filename is in the filter's file_names list,\n        False otherwise.\n    \"\"\"\n    return data[\"file_name\"] in self.file_names\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.filter.CategoryNameFilter","title":"<code>CategoryNameFilter</code>","text":"<p>               Bases: <code>BaseFilter</code></p> <p>Filter categories based on their names.</p> <p>Parameters:</p> Name Type Description Default <code>filter_type</code> <code>FilterType</code> <p>The type of the <code>filter.FilterType.INCLUSION</code> or <code>FilterType.EXCLUSION</code>. If <code>FilterType.INCLUSION</code>, the categories with the names in the <code>category_names</code> are included. If <code>FilterType.EXCLUSION</code>, the categories with the names in the <code>category_names</code> are excluded.</p> required Source code in <code>pycocoedit/objectdetection/filter.py</code> <pre><code>class CategoryNameFilter(BaseFilter):\n    \"\"\"\n    Filter categories based on their names.\n\n    Parameters\n    ----------\n    filter_type : FilterType\n        The type of the ``filter.FilterType.INCLUSION`` or ``FilterType.EXCLUSION``.\n        If ``FilterType.INCLUSION``, the categories with the names in the `category_names` are included.\n        If ``FilterType.EXCLUSION``, the categories with the names in the `category_names` are excluded.\n    \"\"\"\n\n    def __init__(self, filter_type: FilterType, category_names: list[str]):\n        super().__init__(filter_type, TargetType.CATEGORY)\n        self.category_names = category_names\n\n    @override\n    def apply(self, data: dict) -&gt; bool:\n        return data[\"name\"] in self.category_names\n</code></pre>"},{"location":"api/objectdetection/#pycocoedit.objectdetection.filter.BoxAreaFilter","title":"<code>BoxAreaFilter</code>","text":"<p>               Bases: <code>BaseFilter</code></p> <p>Filter annotations based on bounding box area.</p> <p>Parameters:</p> Name Type Description Default <code>filter_type</code> <code>FilterType</code> <p>The type of the <code>filter.FilterType.INCLUSION</code> or <code>FilterType.EXCLUSION</code>. If <code>FilterType.INCLUSION</code>, the data with the area of bbox in the range of <code>min_area</code> and <code>max_area</code> are included. If <code>FilterType.EXCLUSION</code>, the data with the area of bbox in the range of <code>min_area</code> and <code>max_area</code> are excluded.</p> required <code>min_area</code> <code>int or None</code> <p>Minimum area threshold for the filter, default is None.</p> <code>None</code> <code>max_area</code> <code>int or None</code> <p>Maximum area threshold for the filter, default is None.</p> <code>None</code> Notes <p>If both min_area and max_area are None, the filter accepts all areas.</p> Source code in <code>pycocoedit/objectdetection/filter.py</code> <pre><code>class BoxAreaFilter(BaseFilter):\n    \"\"\"\n    Filter annotations based on bounding box area.\n\n    Parameters\n    ----------\n    filter_type : FilterType\n        The type of the ``filter.FilterType.INCLUSION`` or ``FilterType.EXCLUSION``.\n        If ``FilterType.INCLUSION``, the data with the area of bbox in the range of ``min_area`` and ``max_area`` are included.\n        If ``FilterType.EXCLUSION``, the data with the area of bbox in the range of ``min_area`` and ``max_area`` are excluded.\n    min_area : int or None, optional\n        Minimum area threshold for the filter, default is None.\n    max_area : int or None, optional\n        Maximum area threshold for the filter, default is None.\n\n    Notes\n    -----\n    If both min_area and max_area are None, the filter accepts all areas.\n    \"\"\"\n\n    def __init__(\n        self,\n        filter_type: FilterType,\n        min_area: int | None = None,\n        max_area: int | None = None,\n    ):\n        super().__init__(filter_type, TargetType.ANNOTATION)\n        self.min_area = min_area\n        self.max_area = max_area\n\n    @override\n    def apply(self, data: dict) -&gt; bool:\n        if self.min_area is not None and self.max_area is not None:\n            return self.min_area &lt;= data[\"area\"] &lt;= self.max_area\n        elif self.min_area is not None:\n            return self.min_area &lt;= data[\"area\"]\n        elif self.max_area is not None:\n            return data[\"area\"] &lt;= self.max_area\n        return True\n</code></pre>"},{"location":"api/panopticsegmentation/","title":"Panoptic Segmentation","text":"<p>Not yet implemented, but planned for future releases.</p>"},{"location":"develop/release_manual/","title":"Release Manual","text":""},{"location":"develop/release_manual/#prerequisites","title":"Prerequisites","text":"<ul> <li>directly push to the main branch: prohibited (must be merged via PR)</li> <li>development branch name: <code>feature/xxx</code>, <code>fix/xxx</code>, ...</li> <li>Release Branch: <code>release/X.Y.Z</code> (not <code>release/vX.Y.Z</code>)</li> <li>Version: <code>X.Y.Zrc1</code> \u2192 <code>X.Y.Zrc2</code> \u2192 ... \u2192 <code>X.Y.Z</code> (do not use vX.Y.Z)</li> <li>Deployment: Deploy to Test PyPI / PyPI when pushing a tag (push) via GitHub Actions</li> </ul>"},{"location":"develop/release_manual/#release-process","title":"Release Process","text":""},{"location":"develop/release_manual/#0-check-the-main-branch","title":"0. check the main branch","text":"<ul> <li>tests should be passed in the main branch</li> <li>all feature branches should be merged</li> </ul>"},{"location":"develop/release_manual/#1-create-branch-update-version","title":"1. create branch &amp; update version","text":"<ul> <li>create a new <code>release/X.Y.Z</code> branch from <code>main</code> branch<ul> <li>Don't use <code>release/vX.Y.Z</code></li> </ul> </li> <li>run the following command to update the version in <code>pyproject.toml</code> or just edit it manually.</li> </ul> <pre><code>poetry version X.Y.Zrc1\n</code></pre>"},{"location":"develop/release_manual/#2-commit-push","title":"2. commit &amp; push","text":"<ul> <li>push the changes to the <code>release/X.Y.Z</code> branch</li> </ul> <pre><code>git add pyproject.toml\ngit commit -m \"chore: update version to X.Y.Zrc1\"\ngit push origin feature/XXX\n</code></pre> <ul> <li>create a pull request to the <code>main</code> branch. Then tests will be run automatically.</li> <li>All tests should be passed before merging the pull request.</li> </ul>"},{"location":"develop/release_manual/#3-deploy-to-test-pypi","title":"3. Deploy to Test PyPI","text":"<ul> <li>create a tag for the release candidate version</li> <li>tag name must be the same as the version in <code>pyproject.toml</code></li> </ul> <pre><code>git tag X.Y.Zrc1\ngit push origin X.Y.Zrc1\n````\n\n- this will trigger the GitHub Actions to deploy the package to Test PyPI\n\n### 4. install the package from Test PyPI\n\n- install the package from Test PyPI to check if it works correctly\n\n```bash\npip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple pycocoedit==X.Y.Zrc1\n</code></pre> <ul> <li>if there are any issues, fix them in the <code>release/X.Y.Z</code> branch and increment the version to <code>X.Y.Zrc2</code> or <code>X.Y.Zrc3</code>   and push the tag again.</li> </ul>"},{"location":"develop/release_manual/#5-deploy-to-pypi","title":"5. Deploy to PyPI","text":"<ul> <li>once everything is confirmed to be working correctly, change the version in <code>pyproject.toml</code> to <code>X.Y.Z</code> and push the   changes.</li> </ul> <pre><code>poetry version X.Y.Z\ngit add pyproject.toml\ngit commit -m \"chore: update version to X.Y.Z\"\ngit push origin release/X.Y.Z\ngit tag X.Y.Z\ngit push origin X.Y.Z\n</code></pre>"}]}